---
title: "Documentacion Visor de datos"
output: 
  html_document: 
    toc: true
    toc_depth: 6
    toc_float: true
    theme: united
    highlight: tango
    css: "Input\\style.css"  
date: "`r Sys.Date()`"
author: "Victor Brown Sogorb, Nicolas Garcia Gomez, Sara Meda López"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
```

## Introduccion

Este documento de RMarkDown tiene el objetivo de ilustrar con rigurosidad el funcionamiento del Visor de datos usado en este seminario. Para ello, se explicaran como están formadas las diferentes partes de una aplicación Shiny y como estas interactuan entre ellas.

Sin embargo, antes de introducirnos de lleno hay que aclarar unos conceptos claves para comprender una aplicación Shiny.

## Conceptos clave

### UI

La UI o interfaz gráfica es la capa del programa con la que el usuario interactua y está constituida de widgets o elementos gráficos que permiten al usuario seleccionar, introducir, eliminar, accionar... De manera que se confiere interactividad a la aplicación. Estos parámetros que el usuario determina entran dentro de la categoria de INPUT y se podrá acceder a ellos desde el servidor

### Server (Concepto) {#server-concepto}

El server o servidor es la capa del programa en el que se producen todos los cálculos y procesos de la apliación. Se trata de una función con parámetros de input y de output.

```{r, message = F, warning=FALSE}
server <- function(input,output){
  #Logica del servidor
}
```

### Call

El Call o llamada es la linea de codigo que inicializa la apliación e integra la UI y el SERVER

```{r eval=FALSE, message=TRUE, warning=FALSE}
UI <- fluidPage()
SERVER <- function(input,output){}
shinyApp(ui <- UI, server <- SERVER)
```

### Reactividad

Un proceso o una variable se considera reactiva cuando su valor no es fijo y se puede actualizar en función de los inputs que inserte el usuario.

La reactividad es la base de las aplicaciones shiny y es indispensable su uso para el funcionamiento de la aplicación.

Existen varios tipos de entornos reactivos en shiny, los usados en la aplicación son los siguientes:

-   `reactive({})`

-   `observe({})`

-   Funciones tipo render (e.j `renderImage()`, `renderText()`, `renderUI()`...)

Unicamente dentro de estos entornos reactivos se puede hacer uso de la reactividad de las variables.

### Input

El parametro *input* se trata de una lista que se inserta en la función server como parámetro y nos da la capacidad de acceder a la información que el usuario inserta o determina en la UI.

Para ello se utiliza el operador *\$* seguido del *inputid* (e.j input\$archivoGuardado)

```{r,eval=FALSE, warning=FALSE,message=FALSE}
server <- function(input,output){
  # Lógica del server
  var1 <- input$archivoGuardado #Asignacion de la variable con el operador $
}
```

### Output

El parametro output es una lista que se inserta en la función server como parámetro, en está lista se insertarán los diferentes outputs que se generen en el server para que puedan ser usados posteriormente en la UI o donde se requiera su uso.

Para crear un output se utiliza el operador \$ seguido del outputid (e.j output\$imagen)

```{r, eval = FALSE, message=FALSE}
#Interfaz donde se utliza el output
ui <- fluidPage({ 
  title = "Ejemplo"
  textOutput("texto") #Imprime el texto generado por el output
})
#Servidor donde se genera el output
server <- function(input,output){
  output$texto <- renderText("Texto de ejemplo") #Crea el output con el id texto
}
#Lanza la aplicacion
shinyApp(ui <- ui, server <- server)
```

### Widgets {data-link="widgets"}

Un widget es un elemento gráfico que se inserta en la UI y que permite al usuario interactuar con la aplicación de distinta maneras en función del widget. Esta información que proviene del usuario luego puede ser usada para variar los outputs de la apliación. Los widgets que se utilizarán en esta apliación son:

-   [SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput), [SelectizeInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput), [Radiobutton](https://shiny.posit.co/r/reference/shiny/latest/radiobuttons), [SliderInput](https://shiny.posit.co/r/reference/shiny/latest/sliderinput), [TextInput](https://shiny.posit.co/r/reference/shiny/latest/textinput) y [ActionButton](https://shiny.posit.co/r/reference/shiny/latest/actionbutton)

## Visor de datos-Funcionamiento

El visor de datos tiene como objetivo la visualización interactiva de los datasets que van a ser usados para el seminario. Estos datasets serán exportados como csv (separados por ';') y tienen que estar estructurados por columnas de la siguiente forma:

Sexo-Comunidad Autónoma-Dato Categórico- Total relativo(%)

Para más explicaciones del porque remitirse a la documentación de la función `TratamientoDatosGeneral()` del archivo Funciones.R

### Preambulo

Previo al inicio de la aplicación se ejecuta el siguiente código, el cual es indispensable para el funcionamiento de la misma.

```{r, eval = FALSE}
library(shiny)
library(ggplot2)
source("Input\\Funciones.R")
datasets <- list.files("Input\\data")
claseplot <- c("Boxplot", "Histograma", "Density")
```

En esta pequeña porción del codigo de cargan las librerias shiny y ggplot que se utilizarán durante todo el documento. También se hace `source()` del script que contiene las funciones. Además se cargan dos vectores; El primero, `datasets`, contiene todos los archivos dentro de la carpeta *data* donde, presuntamente, solo debería haber los csv correspondientes a los datasets a representar. El segundo vector, `claseplot`, contiene los tipos de gráfico que se van a poder representar con la aplicación.

### Interfaz Gráfica (UI)

El código que forma la UI del visor de datos es sencillo, pese a su aparente complejidad, en este apartado analizaremos cada uno de los componentes de la UI y que papel juega en el aspecto final de la aplicación.

#### Fluidpage y Layout

La primera materia a considerar en el desarrollo de una UI es la organización o layout en la que se van a disponer los elementos de la interfaz. En este caso el Layout elegido es un `sidebarLayout()` que esta formado por un `mainPanel()` (panel principal) y un `sidebarPanel()`(panel lateral).

Este Layout es un parámetro de la función `fluidpage()`, que es un marco que puede alojar varios tipos de Layouts, siendo uno de ellos el `sidebarLayout()`.

En cada uno de estos campos se van a introducir los distintos widgets y outputs que forman la aplicación.

```{r}
#UI------------------------------
ui <- fluidPage(
  #Titulo de la pagina
  titlePanel(h2("Visor de datos")),
  #Utilizamos un sidebarLayout
  sidebarLayout(
    #El panel lateral izquierdo
    sidebarPanel(
      #Informacion dentro del panel lateral
    ),
    mainPanel(
      #Informacion dentro del panel principal
    )
  )
)
```

![SideBarPanel y MainPanel](Input/Imagenes%20Documentacion/Mainpanel_Sidebarpanel.png)

#### SidebarPanel

El sidebarPanel o panel lateral de la aplicación alojará todos los [widgets] necesarios para que el usuario modifique y represente la gráfica que quiera. Cada uno de estos [widgets] determinará una variable reactiva que modificará los diferentes outputs (ver esto en la sección de [Server]).

Antes de introducirnos a fondo con el funcionamiento saber que el panel lateral se ha dividido en dos columnas para una mejor organización de los elementos

Se procederá a explicar uno por uno todos los diferentes widgets usados en el sidebarPanel, también se especificará su respectivo código para futura referencia en el documentos.

##### Dataset 1 (SelectInput) {#dataset-1-selectinput}

**INPUTID: dataset1**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger el primer dataset que se desea representar, las opciones vienen determinadas por el vector `datasets` que contiene todos los documentos de la carpeta `"Input\data"`, la linea que lee los documentos de esta carpeta se encuentra en el [preambulo] (linea 4). El codigo que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
column(6,
        #Se escoge el primer dataset a representar
        helpText(h5("Primer dataset a representar")),
        selectInput("dataset1", "Dataset 1", 
                    choices = datasets),
       #RESTO DE LA COLUMNA
  ),
column(6,
       #Segunda columna del sidebarpanel
       )
  #RESTO DEL SIDEBAR
)
```

![](Input/Imagenes%20Documentacion/Widgets/dataset1.png)

##### Dataset 2 (SelectInput) {#dataset-2-selectinput}

**INPUTID: dataset2**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) similar al [Dataset 1 (SelectInput)](#dataset-1-selectinput), permite seleccionar un segundo dataset a representar.

El codigo que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
column(6,
       #Primera columna del sidebarPanel
       ),
column(6,
       #RESTO DE LA COLUMNA
       
        #Se escoge el segundo dataset a representar
        helpText(h5("Primer dataset a representar")),
        selectInput("dataset2", "Dataset 2", 
                    choices = datasets),
       #RESTO DE LA COLUMNA
  )
  #RESTO DEL SIDEBAR
)

```

![](Input/Imagenes%20Documentacion/Widgets/dataset2.png)

##### Eje x (SelectInput) {#eje-x-selectinput}

**INPUTID: valuex**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger la variable a representar en el eje x, las opciones provienen de las columnas que forman los datasets seleccionados. Para actualizar las opciones en función de estos datasets se utiliza la funcion [`updateselectinput()`](https://shiny.posit.co/r/reference/shiny/latest/updateselectinput) en el apartado de [Server] ([Primer observador (updater)](#primer-observador-updater)).

El codigo que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
column(6,
        #Se escoge el valor del eje x
        helpText(h5("Selecciona el valor x")),
        selectInput("valuex", "Eje x", 
                    choices = "N/A"),
       #RESTO DE LA COLUMNA
  ),
column(6,
       #Segunda columna del sidebarpanel
       )
  #RESTO DEL SIDEBAR
)
```

![](Input/Imagenes%20Documentacion/Widgets/valuex.png)

##### Eje y (SelectInput) {#eje-y-selectinput}

**INPUTID: valuey**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) similar al [Eje x (SelectInput)](#eje-x-selectinput), permite escoger la variable a representar en el eje y.

El codigo que forma este widget es el siguiente:

```{r, eval = F}
sidebarPanel(
column(6,
          #Primera columna del sidebarPanel
       ),
column(6,
       #RESTO DE LA COLUMNA
       
        #Se escoge el valor a representar en el eje y
        helpText(h5("Selecciona el valor y")),
        selectInput("valuey", "Eje y", 
                    choices = "N/A"),
       #RESTO DE LA COLUMNA
  )
  #RESTO DEL SIDEBAR
)
```

![](Input/Imagenes%20Documentacion/Widgets/valuey.png)

##### Tipo de gráfico (SelectInput) {#tipo-de-gráfico-selectinput}

**INPUTID: claseplot**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger la clase de gráfico que se quiere representar, las opciones vienen dadas por el vector `claseplot` cuyos valores se determinan en el [preambulo] (linea 5).

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
column(6,
        #RESTO DE LA COLUMNA
       
        #Se escoge el gráfico a representar
        helpText(h5("Permite seleccionar el tipo de gráfico a representar")),
        selectInput("claseplot", "Tipo de gráfico",
                    choices = claseplot)

  ),
column(6,
       #Segunda columna del sidebarpanel
       )
)
```

![](Input/Imagenes%20Documentacion/Widgets/claseplot.png)

##### Sexo a Representar (SelectInput) {#sexo-a-representar-selectinput}

**INPUTID: sexorepresentar**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger el sexo que se quiere representar, las opciones vienen dadas por el vector descrito en el código, que contiene una opción para cada sexo, otra para Hombres y Mujeres y otra si no se quiere hacer ningún filtrado.

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
column(6,
       #Primera columna del sidebarPanel
       ),
column(6,
       #RESTO DE LA COLUMNA
        #Se escoge el sexo que se quiere representar en los datos
        helpText(h5("Elige el Sexo a representar")),
        selectInput("sexorepresentar", "Sexo a Representar",
                    choices = c("N/A","Hombres","Mujeres","Ambos sexos", "Hombres/Mujeres"))
       #RESTO DE LA COLUMNA
  )
  #RESTO DEL SIDEBAR
)

```

![](Input/Imagenes%20Documentacion/Widgets/sexoarepresentar.png)

##### Panel condicional Boxplot

El panel condicional es una estructura que se muestra en la interfaz si se cumple cierta condición, en este caso, el panel se mostrará si el input elegido en el widget [Tipo de gráfico (SelectInput)](#tipo-de-gráfico-selectinput) es `Boxplot`.

Este panel contendrá los widgets que seleccionen variables que sean relevantes solamente a los [Boxplots](https://es.wikipedia.org/wiki/Diagrama_de_caja), evitando así la aparición de elementos inútiles en la interfaz.

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
  conditionalPanel("input.claseplot == 'Boxplot'", #Condición dada por claseplot
      #WIDGETS DEL PANEL CONDICIONAL
  )
)
```

###### Elemeto mapping (Radiobuttons) {#elemeto-mapping-radiobuttons}

**INPUTID: elementomappingB**

[Radiobuttons](https://shiny.posit.co/r/reference/shiny/latest/radiobuttons) que permiten escoger el elemento en el que se va a hacer el [Mapping] dentro del boxplot. Este widget está dentro del panel condicional del boxplot, ya que solo afecta a este tipo de gráficos.

Las opciones vienen dadas por el vector indicado en el código, que contiene `jitter`, `Box` y `N/A`, estas opciones harán el mapeado en [Geom_Jitter] y [Geom_Boxplot] respectivamente.

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
  conditionalPanel("input.claseplot == 'Boxplot'", #Condición dada por claseplot
      #Se escoge el elemento en el que se va a hacer el mapping
      helpText(h5("Cambia el color de los elementos del gráfico en funcion de otra       variable")),
      radioButtons("elementomappingB", "Elemento que hace el mapping",
                    choices = c("Jitter", "Box", "N/A"))
  )
)

```

![](Input/Imagenes%20Documentacion/Widgets/elementomappingB.png)

##### Panel condicional Histograma

El panel condicional es una estructura que se muestra en la interfaz si se cumple cierta condición, en este caso, el panel se mostrará si el input elegido en el widget [Tipo de gráfico (SelectInput)](#tipo-de-gráfico-selectinput) es `Histograma`.

Este panel contendrá los widgets que seleccionen variables que sean relevantes solamente a los Histogramas, evitando así la aparición de elementos inútiles en la interfaz.

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
 conditionalPanel("input.claseplot == 'Histograma'", #Condición dada por claseplot
      #WIDGETS DEL PANEL CONDICIONAL
  )
)
```

###### Ancho de banda (SliderInput) {#ancho-de-banda-sliderinput}

**INPUTID: binwidth**

[SliderInput](https://shiny.posit.co/r/reference/shiny/latest/sliderinput) que permite escoger el ancho de las bandas del histograma, el slider permite esccoger un valor entre 1 y 30 y tiene un valor inicial de 5.

El ancho de las bandas del histograma representa el rango de datos que recoge cada una de ellas, un valor menor da mayor número de bandas más pequeñas, un valor mayor da menor número de bandas más grandes, sin embargo, a mayor número de bandas se complica la visualización de todas ellas.

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
 conditionalPanel("input.claseplot == 'Histograma'", #Condición dada por claseplot
      #Slider que modifica el ancho de las bandas
      helpText(h5("Cambia el ancho de las bandas")),
      sliderInput("binwidth", "Ancho de banda", min = 1, max = 30, value = 5),
  )
)
```

![](Input/Imagenes%20Documentacion/Widgets/binwidth.png)

##### Panel condicional Density Chart

El panel condicional es una estructura que se muestra en la interfaz si se cumple cierta condición, en este caso, el panel se mostrará si el input elegido en el widget [Tipo de gráfico (SelectInput)](#tipo-de-gráfico-selectinput) es `Density`.

Este panel contendrá los widgets que seleccionen variables que sean relevantes solamente a las density charts, evitando así la aparición de elementos inútiles en la interfaz.

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
 conditionalPanel("input.claseplot == 'Density'", #Condición dada por claseplot
      #WIDGETS DEL PANEL CONDICIONAL
  )
)
```

###### Posición (SelectInput) {#posición-selectinput}

**INPUTID: densityposition**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger la colocación respectiva de las areas que forman la density chart. Las posiciones disponibles en el vector de opciones son `stack`, `fill` y `dodge`. Para más información sobre el cada una de las opciones ver [aquí](https://ggplot2.tidyverse.org/reference/geom_density.html).

El código que forma este widget es el siguiente:

```{r,eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
 conditionalPanel("input.claseplot == 'Density'", #Condición dada por claseplot
  helpText("Modifica la posicion de las areas de densidad respecto a las   demás"),
  selectInput("densityposition","Posicion", choices = c("stack", "fill", "dodge"))
  )
)

```

![](Input/Imagenes%20Documentacion/Widgets/densityposition.png)

##### Variable para mapear (SelectInput) {#variable-para-mapear-selectinput}

**INPUTID: variablemapping**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger la variable con la que se hace el [mapping]. Las opciones se obtendrán de las columnas que formen los datasets que se esten representando, por lo tanto las opciones se irán actualizando con la función [`updateselectinput()`](https://shiny.posit.co/r/reference/shiny/latest/updateselectinput) en el apartado de [Server] ([Primer observador (updater)](#primer-observador-updater)).

El código que forma este widget es el siguiente:

```{r, eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
      #PANELES CONDICIONALES
      #--------
      #--------
  #Escoge la variable con la que se quiere hacer el mapping
  selectInput("variablemapping","Variable con la que se quiere hacer mapping", 
                  choices = "N/A")
)
```

![](Input/Imagenes%20Documentacion/Widgets/variablemapping.png)

##### Nivel a representar (SelectInput) {#nivel-a-representar-selectinput}

**INPUTID: level**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger la categoria que se va a representar de entre los distintos niveles del primer dataset seleccionado, el objetivo de este widget es filtrar aun más los datos para representar más minuciosamente el dataset.

Sus opciones se actualizan utilizando la funcion [`updateselectinput()`](https://shiny.posit.co/r/reference/shiny/latest/updateselectinput) en el apartado de [Server] ([Primer observador (updater)](#primer-observador-updater)).

El código que forma este widget es el siguiente:

```{r, eval = F}
sidebarPanel(
  column(6,
         #Primera columna del sidebarPanel
         ),
  column(6,
         #Segunda columna del sidebarPanel
    ),
      #PANELES CONDICIONALES
      #--------
      #--------
  #Escoge la variable con la que se quiere hacer el mapping
  selectInput("level", "Selecciona el nivel a representar",
                  choices = "N/A")
)

```

![](Input/Imagenes%20Documentacion/Widgets/level.png)

#### Mainpanel

El mainPanel o panel principal alojará todos los outputs generados por el server como la gráfica, el resumen del dataset, el propio dataset, etc. Para la mejor visualización de la información proveniente de los outputs se organizará el panel principal en tabs o ventanas, cada una de ellas contendrá un output distinto. Para ver más sobre tabs en shiny ver [aquí](https://shiny.posit.co/r/getstarted/build-an-app/customizing-ui/tabs.html).

La descripción del panel principal se organizará por tabs, y en cada una se detallará cada componente y output que la forman. Todas las tabs estarán dentro de la función [`navbarPage()`](https://shiny.posit.co/r/reference/shiny/latest/navbarpage)`.`

##### Panel plot

En este panel se renderizará el output que contiene la gráfica, para ello se utiliza la función `plotOutput()` cuyo unico parámetro es el outputid del gráfico a representar, además de varios widgets que ayudarán a la representación y que permiten guardar la imagen de la gráfica.

El output del gráfico se genera aqui ([Output\$plot])

El código del panel con el output es el siguiente:

```{r, eval=F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #Panel donde se observa el plot
        tabPanel(title = "Plot",
                 plotOutput("plot"), #oUTPUT DEL PLOT
                 
                 #WIDGETS QUE CONTIENE EL PANEL
                 
        )
      )
)
```

![](Input/Imagenes%20Documentacion/panelplot.png)

###### Opciones de vista (SelectizeInput) {#opciones-de-vista-selectizeinput}

**INPUTID: viewop**

[SelectizeInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger una o multiples opciones que modifican la vista de la gráfica. Todas estas opciones son generales y comunes a todas las gráficas, excepto casos obvios donde no haya funcionalidad. Las diferentes variables entre las que escoger son:

-Simplificar eje x (id: simpx): esta opción modifica los niveles de la variable categorica que hay en el eje x y los sustituye por valores numericos desde el 1 hasta el número de niveles que haya. Esta opción se utiliza cuando las categorias son tan largas que no se leen en el gráfico. Su implementación en el server es aquí([Output\$summaryx])

-Simplificar eje y (id: simpy): Similar a simpx, pero en el eje y. Su implementación en el server es aquí([Output\$summaryy])

El código que forma este widget es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #Panel donde se observa el plot
        tabPanel(title = "Plot",
          plotOutput("plot"), # plot output
            column(
              width = 6, selectizeInput("viewop","Opciones de Vista", 
              choices = list("Simplificar eje x" = "simpx",
                          "Simplificar eje y" = "simpy"),multiple = T))
          #RESTO DE LA COLUMNA
        )
      )
)
```

![](Input/Imagenes%20Documentacion/Widgets/viewop.png){width="408"}

###### Guardar gráfico (ActionButton) {#guardar-gráfico-actionbutton}

**INPUTID: save**

[ActionButton](https://shiny.posit.co/r/reference/shiny/latest/actionbutton) que, al ser pulsado, guarda el dibujo de la ultima gráfica generada en la carpeta de `Output\OutputPlot`. Los ActionButton pueden ligar el evento de pulsarlo con cualquier otra funcionalidad, para ver la implementación en el server ver aquí: [Segundo observador (save)](#segundo-observador-save).

El código que forma este widget es el siguiente:

```{r, eval = F}
#Panel principal donde se inprime el gráfico
    mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        #Panel donde se observa el plot
        tabPanel(title = "Plot",
                 plotOutput("plot"),
                 
                 #RESTO DEL PANEL
                 
          column(width = 6, helpText("Guarda el gráfico en la carpeta de OutputPlot
                 Para ver el display de las gráficas ir al tab 'Guardados'")
                , actionButton("save", "Guardar Grafico")
          )
        )
      )
    )
```

![](Input/Imagenes%20Documentacion/Widgets/save.png)

###### Nombre del Archivo (TextInput) {#nombre-del-archivo-textinput}

**INPUTID: filename**

[TextInput](https://shiny.posit.co/r/reference/shiny/latest/textinput) que permite al usuario determinar el nombre del archivo PNG en el que se guardará la foto de la gráfica, este TextInput tiene un valor inicial predeterminado que se va actualizando para evitar duplicados en el caso de que no se escoja un nombre manualmente. Este valor se actualiza en el server con la función [`updateTextInput()`](https://shiny.posit.co/r/reference/shiny/latest/updatetextinput) aquí ([Segundo observador (save)](#segundo-observador-save))

El código que forma este widget es el siguiente:

```{r, eval = F}
#Panel principal donde se inprime el gráfico
    mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        #Panel donde se observa el plot
        tabPanel(title = "Plot",
                 plotOutput("plot"),
              
                 #RESTO DEL PANEL
                 
                 textInput("filename", "Nombre del archivo", value = "plot 0"))
        )
    )


```

![](Input/Imagenes%20Documentacion/Widgets/filename.png)

##### Panel Resumen

En este panel se renderizará el output que contiene el resumen de los datos, para ello se utiliza la función [`verbatimTextOutput()`](https://shiny.posit.co/r/reference/shiny/latest/textoutput) cuyo unico parámetro es el outputid del resumen([Output\$resumen]).

El código del panel con el output es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        
        #PANEL DEL PLOT
        
        #Panel donde se ve el resumen
        tabPanel(title = "Resumen",  verbatimTextOutput("resumen"))
      )
)
```

![](Input/Imagenes%20Documentacion/panelresumen.png)

##### Panel data

En este panel se renderizará el output que contiene la tabla con los datos que se representan, la tabla con los datos se genera en el server aquí([Joindatos]) y el output se genera aquí([Output\$tablajoin]).

La función para imprimir el output es [`tableOutput()`](https://shiny.posit.co/r/reference/shiny/latest/rendertable) cuyo unico parámetro es el outputid de la tabla.

El código del panel con el output es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        
        #PANEL DEL PLOT
        
        #PANEL DE RESUMEN
        
        #Panel donde se ven los datos
        tabPanel(title = "Data", tableOutput("tablajoin"))
      )
)

```

![](Input/Imagenes%20Documentacion/paneldata.png)

##### Panel levels

En este panel se renderizará la relación entre los niveles de las variables que se representan y sus niveles una vez aplicada la simplificación utilizando las opciones de simpx y simpy ([Opciones de vista (SelectizeInput)](#opciones-de-vista-selectizeinput)). El texto con esta información se renderiza en el server aquí ([Output\$summaryx] y [Output\$summaryy]).

La función que imprime el output es [`verbatimTextOutput()`](https://shiny.posit.co/r/reference/shiny/latest/textoutput)

El código del panel con el output es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        
        #PANEL DEL PLOT
        
        #Panel donde se ve la relacion entre los niveles y sus respectivos numeros
        # una vez hecha la simplificación de los ejes
        tabPanel(title = "Levels", h3("Leyenda de simplificacion eje x"),
                 verbatimTextOutput("summaryx"),
                 h3("Leyenda de simplificacion eje y"),
                 verbatimTextOutput("summaryy")),
      )
)
```

![](Input/Imagenes%20Documentacion/panellevels.png){width="467"}

##### Panel guardados

En este panel se renderizarán las imágenes que el usuario elija, las imágenes se podrán escoger de las que haya en la carpeta `Output\OutputPlot`, un máximo de 4. Estas imágenes se representarán en el orden elegido. El output se genera en el server aquí ([Output\$imagenes])

La función que imprime el output es [`imageOutput()`](https://shiny.posit.co/r/reference/shiny/latest/plotoutput)

El código del panel con el output es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
tabPanel(title = "Guardados",
                  #WIDGET PARA ELEGIR LSAS IMAGENES
                 imageOutput("imagen1"),
                 br(), #Ocho veces
                 imageOutput("imagen2"),
                 br(), #Ocho veces
                 imageOutput("imagen3"),
                 br(), #Ocho veces
                 imageOutput("imagen4")
            )
      )
)
```

![](Input/Imagenes%20Documentacion/panelguardados.png)

###### Imagenes a representar (SelectizeInput) {#imagenes-a-representar-selectizeinput}

**INPUTID: images**

[SelectizeInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger una o multiples opciones que representan las imágenes de la carpeta `Output\OutputPlot`, se podrán elegir hasta 4 imágenes que se imprimirán en orden.

Las opciones entre las que elegir se irán actualizando cuando se guarde un archivo nuevo, ver la implementación en [Segundo observador (save)](#segundo-observador-save).

El código que forma este widget es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
tabPanel(title = "Guardados",
                 selectizeInput("images","Elige las imagenes a representar",
                                choices = list.files("Output\\OutputPlot"),
                                multiple = T),
                  #OUTPUTS
            )
      )
)
                 
```

![](Input/Imagenes%20Documentacion/Widgets/images.png)

##### Panel GetData

En este panel se podrá extraer ciertos valores estadísticos como la media, min, max, mediana o `summary()` del dataset que el usuario eliga, para ello hay 4 widgets que permiten al usuario filtrar el tipo de información que quiere sacar. El output se genera en la parte del server aquí([Output\$gotData])

La función que imprime el output es [`verbatimTextOutput()`](https://shiny.posit.co/r/reference/shiny/latest/textoutput)

El código del panel con el output es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #DEMÁS PANELES
            tabPanel("GetData",
                #COLUMNAS CON WIDGETS
                verbatimTextOutput("gotdata")
                #COLUMNAS CON WIDGETS
        )        
      )
)

```

![](Input/Imagenes%20Documentacion/panelgetddata.png)

###### Dato a hallar (SelectInput)

**INPUTID: wanteddata**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger los datos estadísticos que se quieren imprimir, las opciones las determina el vector que se observa en el código y cuyos valores son:

-   [Media](https://es.wikipedia.org/wiki/Media_aritm%C3%A9tica), min, max, [mediana](https://es.wikipedia.org/wiki/Mediana_(estad%C3%ADstica)), summary

El código que forma este widget es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #DEMÁS PANELES
            tabPanel("GetData",
                 column(4, 
                        selectizeInput("wanteddata", "Dato que quieres hallar",
                  choices = c("media","min","max","mediana", "summary"), multiple = T))
                 
                 #OTRAS COLUMNAS
                 
                 #OUTPUT
        )        
      )
)


```

![](Input/Imagenes%20Documentacion/Widgets/wanteddata.png)

###### Dataset a hallar (SelectInput) {#dataset-a-hallar-selectinput}

**INPUTID: wanteddataset**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger el dataset del que se quiere extraer la información, las opciones vienen determinadas por el vector `datasets` que contiene todos los documentos de la carpeta `"Input\data"`, la linea que lee los documentos de esta carpeta se encuentra en el [preambulo] (linea 4).

El código que forma este widget es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #DEMÁS PANELES
            tabPanel("GetData",
                  #COLUMNA ANTERIOR
                  
                 column(4, selectInput("wanteddataset", "Dataset del que sacar el                      dato",choices = datasets)),

                 #OTRAS COLUMNAS
                 
                 #OUTPUT
        )        
      )
)

```

![](Input/Imagenes%20Documentacion/Widgets/wanteddataset.png)

###### Sexo a hallar (SelectInput) {#sexo-a-hallar-selectinput}

**INPUTID: wantedsexo**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger el sexo del que se quiere extraer la información dentro del dataset, las opciones vienen dadas por el vector descrito en el código, que contiene una opción para cada sexo, otra para Hombres y Mujeres y otra si no se quiere hacer ningún filtrado.

El código que forma este widget es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #DEMÁS PANELES
            tabPanel("GetData",
                #OTRAS COLUMNAS
                column(3, selectInput("wantedcategoric", "Variable categorica",
                                      choices = "N/A"))
                #OUTPUT
        )        
      )
)

```

![](Input/Imagenes%20Documentacion/Widgets/wantedsexo.png)

###### Categoría a hallar (SelectInput) {#categoría-a-hallar-selectinput}

**INPUTID: wantedcategoric**

[SelectInput](https://shiny.posit.co/r/reference/shiny/latest/selectinput) que permite escoger la categoría de la que se quiere extraer la información, las opciones provienen de los niveles que haya en la columna que contenga la variable categórica del dataset, el valor empieza en N/A y se actualiza en el server utilizando la funcion [`updateselectinput()`](https://shiny.posit.co/r/reference/shiny/latest/updateselectinput) en el apartado de [Server] ([Tercer Observador (getData)](#tercer-observador-getdata)).

El código que forma este widget es el siguiente:

```{r, eval = F}
mainPanel(
      #Barra de navegación para acceder a los distintos elementos
      navbarPage(
        title = strong("VISTA"),
        #DEMÁS PANELES
            tabPanel("GetData",
                #OTRAS COLUMNAS
               column(3, selectInput("wantedcategoric", "Variable categorica",
                    choices = "N/A"))
                #OUTPUT
        )        
      )
)


```

![](Input/Imagenes%20Documentacion/Widgets/wantedcategoric.png)

### Server {data-link="Server"}

La función de [Server (Concepto)](#server-concepto) es la que realiza todos los calculos de la aplicación y, por tanto, es la encargada de generar todos los outputs que se imprimen en el [MainPanel], en este apartado analizaremos con rigurosidad cada output generado y todas las variables que entran en su creación.

El análisis se dividirá en tres apartados, variables globales, observadores y outputs.

#### Variables Globales

Estas variables son aquellas variables reactivas que se inician en el servidor y se van actualizando en función de los inputs que el usuario determina en la UI. La razón del uso del termino "global" se debe a que estas no se encuentran alojadas dentro de la definición de ningún output, si no que se crean fuera de ellos para evitar repetición de código.

Las variables globales son las siguientes:

##### Joindatos

Esta variable reactiva contiene el conjunto de los datos que representan, es decir, debido a que ggplot requiere un único dataset del que extraer los datos se requiere fusionar los dos datasets elegidos en los inputs [Dataset 1 (SelectInput)](#dataset-1-selectinput) y [Dataset 2 (SelectInput)](#dataset-2-selectinput).

Esta fusión se realiza con la función `cbind()`, que permite juntar dos dataframes "pegando" sus columnas, sin embargo, esta función tiene limitaciones que serán discutidas más tarde. Se procederá a analizar el funcionamiento del código.

Esta primera parte de la expresión reactiva extrae la información de los csv que el usuario determina en los inputs [Dataset 1 (SelectInput)](#dataset-1-selectinput) y [Dataset 2 (SelectInput)](#dataset-2-selectinput) y les aplica la función `TratamientosDatosGeneral()` (más información en la documentación de Funciones.R).

```{r, eval = F}
server <- function(input, output, session){
    #Expresion reactiva que genera el conjunto de datos que sale de hacer un join      de los dos datasets
    joindatos <- reactive({
      #Abre y trata los datasets seleccionados en los select de la UI
      dataset_seleccionado_1 <- 
      read.csv(paste("Input\\data\\", input$dataset1, sep= ""), sep = ";")
      dataset_seleccionado_1 <- TratamientoDatosGeneral(dataset_seleccionado_1)
      dataset_seleccionado_2 <- 
      read.csv(paste("Input\\data\\", input$dataset2, sep= ""), sep = ";")
      dataset_seleccionado_2 <- TratamientoDatosGeneral(dataset_seleccionado_2)
      #
      # RESTO DE LA EXPRESIÓN
      #
    })
}

```

Esta segunda parte de la expresión une los datasets seleccionados y elimina las filas extras, esto ocurre si se cumplen dos condiciones, indicadas por las expresiones tipo if:

-   Que los dos datasets no sean el mismo, en cuyo caso se dejara solo uno de ellos.

-   Que los dos datasets tengan el mismo número de filas (limitaciones de `cbind()`), en caso contrario deja el dataset 1

```{r, eval = F}
server <- function(input, output, session){
      #Expresion reactiva que genera el conjunto de datos que sale de hacer un join      de los dos datasets
      joindatos <- reactive({
        #
        # CODIGO ANTERIOR
        #
      #Si los dos sets de datos son el mismo, solo devuelve uno de ellos
      if(input$dataset1 == input$dataset2){ 
        joindatos <- dataset_seleccionado_1
      } else if(nrow(dataset_seleccionado_1) == nrow(dataset_seleccionado_2)){ 
        #En caso contrario une los datasets utilizando cbind()
        joindatos <- cbind(x = dataset_seleccionado_1, y = dataset_seleccionado_2)
        #Elimina las columnas extras
        joindatos$y.Sexo <- NULL 
        joindatos$y.Comunidades.y.Ciudades.Autónomas <- NULL
      } else{
        joindatos <- dataset_seleccionado_1
      }
        #
        # RESTO DE LA EXPRESIÓN
        #
      })
}

```

En la tercera parte de la expresión se filtra y se devuelve los datos en función del input [Sexo a Representar (SelectInput)](#sexo-a-representar-selectinput), para ello se filtra la primera columna del dataframe, sabiendo que esta es la que contiene la información del sexo.

```{r, eval = F}
server <- function(input, output, session){
      #Expresion reactiva que genera el conjunto de datos que sale de hacer un join      de los dos datasets
      joindatos <- reactive({
        #
        # CODIGO ANTERIOR
        #
      #Cambia los datos en función del sexo que se quiere representar
      if(input$sexorepresentar == "N/A"){
        joindatos
      }else if(input$sexorepresentar == "Hombres/Mujeres"){
        joindatos[joindatos[,1] == "Hombres" | joindatos[,1] == "Mujeres",]
      }else {
        joindatos[joindatos[,1] == input$sexorepresentar,]
      }
    })
}

```

##### Vectores disponibles

Esta variable contiene el nombre de las columnas del dataFrame [Joindatos], la implementación es bastante simple y se utiliza en los updatesSelectInput del sector de observe(#TODO).

El código que lo forma es el siguiente

```{r, eval = F}

#SERVER------------------------------------
server <- function(input, output, session){
    #Expresion reactiva que devuelve un vector con las columnas unicas disponibles
    #que se encuentran en los datasets que se han seleccionado
    vectores_disponibles <- reactive({
      colnames(joindatos())
    })
}

```

#### Observadores

Los observadores son expresiones rodeadas por la función [`observe()`](https://shiny.posit.co/r/reference/shiny/latest/observe.html) que funciona de manera similar a la función [`reactive()`](https://shiny.posit.co/r/reference/shiny/latest/reactive.html) en ciertos aspectos pero se diferencia de ella en función. Las dos crean un entorno reactivo, pero la función observe actualiza el estado de la expresión que contiene periódicamente, de forma que sin necesidad de que cambie ninguna variable se pueden llamar a funciones de interes o modificar otros outputs.

##### Primer observador (updater) {#primer-observador-updater}

Este observador contiene la función [`updateselectinput()`](https://shiny.posit.co/r/reference/shiny/latest/updateselectinput) tres veces, de forma que actualiza los valores de los selectInput [Eje x (SelectInput)](#eje-x-selectinput), [Eje y (SelectInput)](#eje-y-selectinput) y [Variable para mapear (SelectInput)](#variable-para-mapear-selectinput), estos tres widgets utilizan el mismo vector en el apartado de opciones [Vectores disponibles].

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Observer que actualiza los selects de la UI con el vector que se obtiene de la expresión 
    #reactiva anterior
    observe({
      updateSelectInput(session = session, inputId = "valuex", choices =  vectores_disponibles())
      updateSelectInput(session = session, inputId = "valuey", choices = vectores_disponibles())
      updateSelectInput(session = session, inputId = "variablemapping", choices = vectores_disponibles())
      updateSelectInput(session = session, inputId = "level", choices = c("N/A",levels(joindatos()[,3])))
      })
}
```

##### Segundo observador (save) {#segundo-observador-save}

Este observador es el que se encarga de manejar la implementación de la función de guardado de imágenes, por ello el observador esta unido al evento que ocurre al presionar [Guardar gráfico (ActionButton)](#guardar-gráfico-actionbutton) gracias a la función [`bindEvent()`](https://shiny.posit.co/r/reference/shiny/latest/bindevent).

El observador contiene las funciones [`ggsave()`](https://www.rdocumentation.org/packages/ggplot2/versions/3.5.0/topics/ggsave), [`updateTextInput()`](https://shiny.posit.co/r/reference/shiny/latest/updatetextinput) y [`updateSelectizeInput()`](https://shiny.posit.co/r/reference/shiny/latest/updateselectinput).

La primera tiene como objetivo guardar la imagen **(.png)** del último gráfico generado en la carpeta `Output\OutputPlot`, las dimensiones de la imagen son las más adecuada para gráficos de este estilo.

Las dos funciones siguientes actualizan los valores de los widgets [Nombre del Archivo (TextInput)](#nombre-del-archivo-textinput) y [Imagenes a representar (SelectizeInput)](#imagenes-a-representar-selectizeinput) respectivamente.

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Observador que guarda el último plot impreso en la carpeta designada
   # para que se active hay que presionar el botón de guardar
   observe({
     ggsave(filename = paste(input$filename,".png", sep = ""), 
            path = "Output\\OutputPlot", width = 1100, height = 500, units = "px", dpi = 100)
     
    updateTextInput(session,"filename", value = paste("plot",input$save, sep = ""))
     updateSelectizeInput(session, "images", choices = list.files("Output\\OutputPlot"))
   }) |> bindEvent(input$save)
}
```

##### Tercer Observador (getData) {#tercer-observador-getdata}

Este tercer observador se encarga de manejar la implementación de las funciones del [Panel GetData] debido a que inicia y actualiza la variable de `wanteddataset`, cargando en ella el csv correspondiente al elegido en el widget [Dataset a hallar (SelectInput]) y posteriormente aplicándole la función `TratamientoDatosGeneral()`, además actualiza las opciones del widget [Categoría a hallar (SelectInput)](#categoría-a-hallar-selectinput) en función de los niveles de la variable categórica de `wanteddataset`.

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
        #Observador que guarda el último plot impreso en la carpeta designada
       # para que se active hay que presionar el botón de guardar
     observe({
         wanteddataset <- read.csv(paste("Input\\data\\", 
                                         input$wanteddataset, sep = ""), sep = ";")
         wanteddatasetT <- TratamientoDatosGeneral(wanteddataset)
         updateSelectInput(session = session, inputId = "wantedcategoric",
                           choices = levels(wanteddatasetT[,3]))
       })
}
```

#### Outputs

Los [Output]s son la parte más importante del funcionamiento de la aplicación junto con los [Input]s ya que estos son los elementos que serán impresos por pantalla en función de los inputs del usuario. Para generar esto inputs se utilizan funciones tipo `render`, que generan el output deseado, a la hora de imprimirlos en la UI se utilizan funciones tipo `Output`, como se ha podido ver en los apartados dedicados a los outputs en el [MainPanel].

Se procederá a listar y explicar todos los Outputs que se utilizan en la apliación:

##### Output\$plot

Este output se trata de un plot o gráfico y utiliza la función [`renderPlot()`](https://shiny.posit.co/r/reference/shiny/latest/renderplot) que cualquier una expresión que genere un gráfico, para generar el gráfico se utiliza el paquete **ggplot2** en especifico la función [`ggplot(`](https://ggplot2.tidyverse.org/reference/ggplot.html)`)`. Se procederá a la explicación interna del código.

La primera parte de la expresión dentro del `renderPlot()` inicializa las variables internas necesarias para renderizar el plot, que son:

-   joindatos: contiene los datasets (ver más en [Joindatos])

-   tipográfico: tipo de gráfico a representar (ver más en [Tipo de gráfico (SelectInput)](#tipo-de-gráfico-selectinput))

-   elemetomappingB: elemento a mapear en caso de tipográfico == "Boxplot (ver más en [Elemeto mapping (Radiobuttons)](#elemeto-mapping-radiobuttons))

-   variablemapping: variable a mapear (ver más en [Variable para mapear (SelectInput)](#variable-para-mapear-selectinput))

-   binwidth: ancho de banda del histograma (ver más en [Ancho de banda (SliderInput)](#ancho-de-banda-sliderinput))

-   valorx: variable a representar en el eje x (ver más en [Eje x (SelectInput)](#eje-x-selectinput))

-   valory: variable a representar en el eje y (ver más en [Eje y (SelectInput)](#eje-y-selectinput))

-   levelrepresentar: nivel que se quiere representar (ver más en [Nivel a representar (SelectInput)](#nivel-a-representar-selectinput))

Además de iniciar todas estas variables también se implementa la función de simplificación de los ejes, como fue explicado en [Opciones de vista (SelectizeInput)](#opciones-de-vista-selectizeinput), dependiendo de los valores de este input se simplifican los niveles de las columnas representadas como valor x y valor y, notese que este cambio en los niveles es interno a la función `renderplot()`, es decir, no se modifican los datos en ningún otro entorno reactivo.

También se filtra el dataset en función del nivel que se escoge para representar.

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Genera el plot final
    output$plot <- renderPlot({
      joindatos <- joindatos()
      tipografico <- input$claseplot #Tipo de gráfico a representar
      elementomappingB <- input$elementomappingB #Elemento a mapear en el boxplot
      variablemapping <- input$variablemapping #Variable con la que se hace el mapping
      binwidth <- input$binwidth #Ancho de banda del histograma
      valorx <- input$valuex #Variable del eje x
      valory <- input$valuey #Variable del eje y
      levelrepresentar <- input$level #Nivel a representar
      #Simplifica los levels del ejex o del ejey si asi se escoge
      if(levelrepresentar != "N/A"){
        joindatos <- joindatos[joindatos[,3] == levelrepresentar,]
      }
      if("simpx" %in% input$viewop){
       levels(joindatos[[valorx]]) <- seq(1,length(joindatos[[valorx]]))
      } 
      if("simpy" %in% input$viewop){
        levels(joindatos[[valory]]) <- seq(1,length(joindatos[[valory]]))
      }
      #
      # RESTO DE LA EXPRESION
      #
    })
}

```

La segunda parte de la expresión es la que forma la gráfica con la función `ggplot()`, primeramente se inicia el "esqueleto" de la gráfica, es decir, se indica el dataset donde extraer los datos y las columnas que van en el eje x y en el eje y, notese que para poder indicar a la funcion [`aes()`](https://ggplot2.tidyverse.org/reference/aes.html) los valores de los ejes no se puede utilizar el operador \$ o indicar la variable literalmente (e.j `aes(x = valorx, y= valory)`), en su lugar se utiliza la expresión `aes(.data[[valorx]]...)`.

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Genera el plot final
    output$plot <- renderPlot({
      #
      # INICIALIZACION DE VARIABLES
      #
      
      #Inicializa la gráfica con los datos elegidos e inserta los labels de los ejes
      p <- ggplot(data = joindatos, 
                  aes(x = .data[[valorx]] , y = .data[[valory]])) 
      if(input$dataset1 == input$dataset2){
        p <- p + ggtitle(input$dataset1)
      } else{
        p <- p + ggtitle(paste(input$dataset1, input$dataset2, sep = "/"))
      }
      #
      # RESTO DE LA EXPRESION
      #
    })
}

```

La tercera parte de la expresión filtra y devuelve el gráfico en función del tipo elegido([Tipo de gráfico (SelectInput)](#tipo-de-gráfico-selectinput)). Dependiendo del tipo lleva a cabo operaciones distintas:

-   Boxplot: si el valor de elementomappingB ([Elemeto mapping (Radiobuttons)](#elemeto-mapping-radiobuttons)) es jitter añade a la gráfica el [Geom_Boxplot] y el [Geom_Jitter] mapeando el color dentro de `geom_jitter()` con la función [`aes(`](https://ggplot2.tidyverse.org/reference/aes.html)`)` . Por otro lado si elementomappingB es boxplot añade las mismas gráficas pero el mapeado esta dentro de `geom_boxplot()`. Por último, si el valor es N/A, no se mapea en ninguno de los dos gráficos.

    ```{r, eval = F}

    #SERVER------------------------------------
    server <- function(input, output, session){
        #Genera el plot final
        output$plot <- renderPlot({
          #
          # EXPRESION ANTERIOR
          #
          #Si el tipo de gráfico elgido es un boxplot
          if(tipografico == "Boxplot"){
            if(elementomappingB == "Jitter"){             #Pinta el jitter
              q <- p + geom_boxplot(alpha = 0.8) + geom_jitter(aes(colour = .data[[variablemapping]]))
            } else if(elementomappingB == "Box"){         #Pinta las boxes
              q <- p + geom_boxplot(aes(colour = .data[[variablemapping]]), alpha = 0.8)
            } else{
              q <- p + geom_boxplot() + geom_jitter() #No pinta nada
            }}
          #
          # RESTO DE LA EXPRESION
          #
          })
    }
    ```

-   Histograma: los histogramas solo piden una variable en el eje x y da un error si existe un valor de eje y, por tanto, antes de hacer el histograma se vuelve a generar el plot solo con la variable del eje x, posteriormente se añade la función [Geom_histogram] con los valores reactivos de binwidth ([Ancho de banda (SliderInput)](#ancho-de-banda-sliderinput)) y la variable a mapear([Variable para mapear (SelectInput)](#variable-para-mapear-selectinput)).

    Notese que los histogramas solo funcionan con valores numéricos, es decir, saltará un error si se intenta representar un valor categórico.

    ```{r, eval = F}

    #SERVER------------------------------------
    server <- function(input, output, session){
        #Genera el plot final
        output$plot <- renderPlot({
          #
          # EXPRESION ANTERIOR
          #
          if(tipografico == "Boxplot"){
            #EXPRESION DEL BOXPLOT
          } else if(tipografico == "Histograma"){
            p <- ggplot(data = joindatos, 
                        aes(x = .data[[valorx]])) #Quita el valor y del gráfico para adaptarse a un histograma
            #Pinta el histograma y rellena el fill con la categoria elegida
            q <- p + geom_histogram(binwidth = binwidth  ,color = "black", aes(fill = .data[[variablemapping]])) 
          }
          #
          # RESTO DE LA EXPRESION
          #
          })
    }
    ```

-   Density: las density charts funcionan de manera similar a los histogramas en el aspecto de que solo admiten un valor a representar(eje x), por tanto, como hicimos con el histograma, se vuelve a generar el plot solo con la variable del eje x, posteriormente de añade la funcion [Geom_density] con los valores reactivos de posición([Posición (SelectInput)](#posición-selectinput)) y la variable a mapear([Variable para mapear (SelectInput)](#variable-para-mapear-selectinput)).

```{r, eval = F}

#SERVER------------------------------------
server <- function(input, output, session){
    #Genera el plot final
    output$plot <- renderPlot({
      #
      # EXPRESION ANTERIOR
      #
      if(tipografico == "Boxplot"){
        #EXPRESION DEL BOXPLOT
      } else if(tipografico == "Histograma"){
        #EXPRESION DEL HISTOGRAMA
      }  else if(tipografico == "Density"){
        p <- ggplot(data = joindatos, 
                    aes(x = .data[[valorx]]))
       q <- p + geom_density(aes(fill = .data[[variablemapping]]), position = input$densityposition)
      }
      })
}
```

Por último, también se añade a la gráfica el label de los ejes, la función `theme()` que permite modificar el estilo, tamaño y color de distintas partes de la gráfica y el título de la gráfica formado por el nombre de los datasets a representar.

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Genera el plot final
    output$plot <- renderPlot({
      #
      # EXPRESION ANTERIOR
      #
        q + 
        xlab(valorx) + 
        ylab(valory) +
            #Cambia el color y tamaño de los ejes
            theme(axis.title.x = element_text(colour = "Darkblue", size = 20),
                  axis.title.y = element_text(colour = "Darkblue", size = 20),
                  axis.text.x = element_text(size =15, colour = "black"),
                  axis.text.y = element_text(size = 15, colour = "black"),
                  
                  plot.title = element_text(size = 20, colour = "black", hjust = 0.5)
            )
    })
}
```

##### Output\$tablajoin

Este sencillo output imprime la tabla de los datos que se van a representar, siendo estos datos [Joindatos], para ello utiliza la funcion [`renderTable()`](https://shiny.posit.co/r/reference/shiny/latest/rendertable) que acepta expresiones que generen una tabla, en este caso solo con insertar el dataset ya devuelve la tabla correspondiente.

El código que forma el output es el siguiente:

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Genera un output con los datos que se están representando en forma de tabla
   output$tablajoin <- renderTable({
    joindatos()
    })
}
```

##### Output\$resumen

Este output imprime el resumen de los datos a representar ([Joindatos]) con la función [`renderprint()`](https://shiny.posit.co/r/reference/shiny/latest/renderprint) y [`summary()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary).

El código que forma el output es el siguiente:

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
    #Genera un output con los datos que se están representando en forma de tabla
   #Genera un output con el resumen de los datos que se representan
   output$resumen <- renderPrint({
    summary(joindatos())
    }) 
}
```

##### Output\$summaryx {data-link="Output$resumen"}

Este output genera un print con la relación entre los niveles del valor x y la secuencia de números de la misma longitud, este print le da al usuario la capacidad de ver los nombres de los niveles cuando se utiliza la función de simplificar el eje x ([Opciones de vista (SelectizeInput)](#opciones-de-vista-selectizeinput))

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
   #Genera un output que muestra la relacion entre los números 
   #de simplificación en el eje x y sus valores en el dataset
   output$summaryx <- renderPrint({
     valorx <- input$valuex
     x <- 1
     for(r in levels(joindatos()[[valorx]])){
       print(paste(x,r, sep = " ------> "))
       x <- x + 1
     }
   })
}
```

##### Output\$summaryy {data-link="Output$resumen"}

Este output genera un print con la relación entre los niveles del valor y y la secuencia de números de la misma longitud, este print le da al usuario la capacidad de ver los nombres de los niveles cuando se utiliza la función de simplificar el eje y ([Opciones de vista (SelectizeInput)](#opciones-de-vista-selectizeinput))

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
   #Genera un output que muestra la relacion entre los números 
   #de simplificación en el eje y y sus valores en el dataset
   output$summaryy <- renderPrint({
     valory <- input$valuey
     x <- 1
     for(r in levels(joindatos()[[valory]])){
       print(paste(x,r, sep = " ------> "))
       x <- x + 1
     }
   })
}

```

##### Output\$imagenes {data-link="Output$resumen"}

Estos outputs renderizan las imágenes escogidas por el usuario en [Imagenes a representar (SelectizeInput)](#imagenes-a-representar-selectizeinput) en el tab de Guardados([Panel guardados]). Para renderizsar estas imágenes se utiliza la función [`renderImage()`](https://shiny.posit.co/r/reference/shiny/latest/renderimage) que pide una expresión que genere una imagen, la expresión final debe contener una lista con el path a la imagen y ciertos parámetros que determinan su tamaño.

En cada uno de los outputs (imagen1, imagen2, imagen3 e imagen4) se genera el path a la imagen correspondiente.

El código de estos outputs es el siguiente:

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
   #Imagen 1
   output$imagen1 <- renderImage({
      path <- paste("Output\\OutputPlot\\", input$images[1], sep = "")
      list(src = path,
           width = "1100",
           height = "500",
           scale = 0.5,
           alt = h3("Selecciona una imagen"))
    }, deleteFile = F)
   #Imagen 2
   output$imagen2 <- renderImage({
     path <- paste("Output\\OutputPlot\\", input$images[2], sep = "")
     list(src = path,
          width = "1100",
          height = "500",
          scale = 0.5,
          alt = h3("Selecciona una imagen"))
   }, deleteFile = F)
   #Imagen 3
   output$imagen3 <- renderImage({
     path <- paste("Output\\OutputPlot\\", input$images[3], sep = "")
     list(src = path,
          width = "1100",
          height = "500",
          scale = 0.5,
          alt = h3("Selecciona una imagen"))
   }, deleteFile = F)
   #Imagen 4
   output$
     imagen4 <- renderImage({
     path <- paste("Output\\OutputPlot\\", input$images[4], sep = "")
     list(src = path,
          width = "1100",
          height = "500",
          scale = 0.5,
          alt = h3("Selecciona una imagen"))
   }, deleteFile = F)
}
```

##### Output\$gotData {data-link="Output$resumen"}

Este output genera un print con los datos que el usuario desea hallar de los datasets utilzando la función [`renderprint()`](https://shiny.posit.co/r/reference/shiny/latest/renderprint). Para ello, primeramente se carga el dataset indicado en el widget [Dataset a hallar (SelectInput)](#dataset-a-hallar-selectinput), se le trata utilizando la función `TratamientoDatosGeneral()` y se filtra el sexo en función del valor de [Sexo a hallar (SelectInput)](#sexo-a-hallar-selectinput) y el level indicado en [Categoría a hallar (SelectInput)](#categoría-a-hallar-selectinput).

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
  #Output de datos
   output$gotdata <- renderPrint({
    dataset <- read.csv(paste("Input\\data\\", input$wanteddataset, sep = ""), sep = ";")
    dataset <- TratamientoDatosGeneral(dataset)
    if(input$wantedsexo == "Hombres/Mujeres"){
       dataset <- dataset[dataset[,1] == "Hombres" | dataset[,1] == "Mujeres",]
    } else if(input$wantedsexo != "N/A"){
       dataset <- dataset[dataset[,1] == input$wantedsexo,]
    }
    dataset <- dataset[dataset[,3] == input$wantedcategoric,]
    #
    # RESTO DE LA EXPRESION
    #
   })
}
```

Por último, en función del dato o datos que el usuario desea saber se imprime cada uno de ellos:

```{r, eval = F}
#SERVER------------------------------------
server <- function(input, output, session){
  #Output de datos
   output$gotdata <- renderPrint({
    #
    # COMIENZO DE LA EXPRESION
    #
     if("media" %in% input$wanteddata){
       media <- sum(dataset[,4])/nrow(dataset)
       print(paste("MEDIA:", media, sep = " "))
     } 
     if("min" %in% input$wanteddata){
       min <- min(dataset[,4])
       print(paste("MIN:", min, sep = " "))
     }
     if("max" %in% input$wanteddata){
       max <- max(dataset[,4])
       print(paste("MAX:", max, sep = " "))
     }
     if("mediana" %in% input$wanteddata){
       median = median(dataset[,4])
       print(paste("MEDIANA:", median, sep = " "))
     } if("summary" %in% input$wanteddata){
      summary(dataset[,4])
    }
  })
}
   

```

## Conceptos de interes

### Mapping {data-link="Mapping"}

El mapping o mapeado en este contexto se puede definir como el proceso de indicar visualmente la composición de un conjunto de datos en función de determinadas categorías asociadas con estos datos. Por ejemplo, podemos mapear las categorías de ejercicio físico en un histograma que representa la frecuencia de los valores numéricos del total. Como se puede observar aquí:

![](Input/Imagenes%20Documentacion/ejemplomapping.png)

### Geom_density {data-link="Mapping"}

La función `geom_density()` es la proporcionada por **ggplot2** para representar los valores indicados en la función `ggplot()` como un gráfico de densidad, se añade al resultado de la función `ggplot()` con el operador `+` . `geom_density()` solo acepta una dimensión de representación, el eje x, y se puede cambiar la posición relativa de las areas de la gráfica en el parámetro position.

Más detalles en la documentación de la función ([aquí](https://ggplot2.tidyverse.org/reference/geom_density.html)).

![](Input/Imagenes%20Documentacion/ejemplo_geom_density.png)

### Geom_histogram {data-link="Mapping"}

La función `geom_histogram()` es la proporcionada por **ggplot2** para representar los valores indicados en la funcion `ggplot()` como un histograma. `geom_histogram()` solo acepta una dimensión de representación, el eje x, además este valor debe ser numérico ya que `geom_histogram()` no trabaja con valores categóricos, para ese proposito se utiliza `geom_bar()`.

Para más información sobre la función ir [aquí](https://www.rdocumentation.org/packages/ggplot2/versions/0.9.1/topics/geom_histogram).

![](Input/Imagenes%20Documentacion/ejemplo_geom_histogram.png)

### Geom_Jitter {data-link="Mapping"}

La función `geom_jitter()` es la proporcionada por **ggplot2** para representar los valores indicados en la funcion `ggplot()` como un conjunto de puntos. Esta función es un atajo a la expresión `geom_point(position = "jitter")`. La posición jitter añade una pequeña variación aleatoria a las posiciones de los puntos, es util para representar de otra manera la concentración de valores cuando se sobreescribe en otras visiones estadísticas como `geom_boxplot()`.

Para más información sobre la función ir [aquí](https://ggplot2.tidyverse.org/reference/geom_jitter.html).

![](Input/Imagenes%20Documentacion/ejemplo_geom_jitter.png)

### Geom_Boxplot {data-link="Mapping"}

La función `geom_boxplot()` es la proporcionada por **ggplot2** para representar los valores indicados en la funcion `ggplot()` como un diagrama de caja. Las cajas representan una serie de datos numéricos a traves de su visualización en cuartiles (la caja está formada por el segundo y tercer cuartil), también se puede obsevar con claridad la mediana y los valores atípicos.

Para más información sobre la función ir [aquí](https://ggplot2.tidyverse.org/reference/geom_jitter.html).

![](Input/Imagenes%20Documentacion/ejemplo_geom_boxplot.png)

## Limites del visor

Este visor de datos, pese a la gran funcionalidad que tiene, presenta varias limitaciones en función e implementación.

Esto es debido a que, por ahora, su uso está restringido únicamente a este seminario gracias a que los datos a representar deben de tener una estructura determinada para que todo funciones de manera correcta.

También cabe mencionar que el visor se limita a ser una herramienta util para la visualización y filtrado de los datasets que vamos a utlizar en el trabajo, pero por si solo no nos ayuda a sacar conclusiones respecto al tema que se trata en el seminario, siendo este la relación entre los determinantes de salud y el estado general de salud con contexto comparativo entre datos de varios años.

Dicho esto, ha sido para mi un gran aprendizaje el programar y documentar el visor aquí presentado.

Gracias por leer.
